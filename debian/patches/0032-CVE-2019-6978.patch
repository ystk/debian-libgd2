Index: libgd2-2.1.0/src/gd_gif_out.c
===================================================================
--- libgd2-2.1.0.orig/src/gd_gif_out.c	2019-01-29 14:48:25.552398898 +0100
+++ libgd2-2.1.0/src/gd_gif_out.c	2019-01-29 14:48:25.536398898 +0100
@@ -93,13 +93,18 @@
 static void char_out(int c, GifCtx *ctx);
 static void flush_char(GifCtx *ctx);
 
+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);
+
 BGD_DECLARE(void *) gdImageGifPtr(gdImagePtr im, int *size)
 {
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) return NULL;
-	gdImageGifCtx(im, out);
-	rv = gdDPExtractData(out, size);
+        if (!_gdImageGifCtx(im, out)) {
+                rv = gdDPExtractData(out, size);
+        } else {
+                rv = NULL;
+        }
 	out->gd_free(out);
 	return rv;
 }
@@ -114,6 +119,12 @@
 
 BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
+       _gdImageGifCtx(im, out);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
+{
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
 	interlace = im->interlace;
@@ -124,7 +135,7 @@
 		based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if(!pim) {
-			return;
+			return 1;
 		}
 		tim = pim;
 	}
@@ -140,6 +151,8 @@
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
+
+        return 0;
 }
 
 BGD_DECLARE(void *) gdImageGifAnimBeginPtr(gdImagePtr im, int *size, int GlobalCM, int Loops)
@@ -849,7 +862,6 @@
 #define HashTabOf(i) ctx->htab[i]
 #define CodeTabOf(i) ctx->codetab[i]
 
-
 /*
  * To save much memory, we overlay the table used by compress() with those
  * used by decompress().  The tab_prefix table is the same size and type
Index: libgd2-2.1.0/src/gd_jpeg.c
===================================================================
--- libgd2-2.1.0.orig/src/gd_jpeg.c	2019-01-29 14:48:25.552398898 +0100
+++ libgd2-2.1.0/src/gd_jpeg.c	2019-01-29 14:48:25.540398898 +0100
@@ -118,6 +118,8 @@
 	exit(99);
 }
 
+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);
+
 /*
  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality
  * QUALITY.  If QUALITY is in the range 0-100, increasing values
@@ -140,8 +142,11 @@
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) return NULL;
-	gdImageJpegCtx(im, out, quality);
-	rv = gdDPExtractData(out, size);
+	if (!_gdImageJpegCtx(im, out, quality)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free(out);
 	return rv;
 }
@@ -150,6 +155,12 @@
 
 BGD_DECLARE(void) gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
 {
+	_gdImageJpegCtx(im, outfile, quality);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
+{
 	struct jpeg_compress_struct cinfo;
 	struct jpeg_error_mgr jerr;
 	int i, j, jidx;
@@ -183,7 +194,7 @@
 		if(row) {
 			gdFree(row);
 		}
-		return;
+		return 1;
 	}
 
 	cinfo.err->emit_message = jpeg_emit_message;
@@ -220,7 +231,7 @@
 	if(row == 0) {
 		gd_error("gd-jpeg: error: unable to allocate JPEG row structure: gdCalloc returns NULL\n");
 		jpeg_destroy_compress(&cinfo);
-		return;
+		return 1;
 	}
 
 	rowptr[0] = row;
@@ -297,6 +308,7 @@
 	jpeg_finish_compress(&cinfo);
 	jpeg_destroy_compress(&cinfo);
 	gdFree(row);
+	return 0;
 }
 
 BGD_DECLARE(gdImagePtr) gdImageCreateFromJpeg(FILE *inFile)
Index: libgd2-2.1.0/src/gd_wbmp.c
===================================================================
--- libgd2-2.1.0.orig/src/gd_wbmp.c	2019-01-29 14:48:25.552398898 +0100
+++ libgd2-2.1.0/src/gd_wbmp.c	2019-01-29 14:48:25.540398898 +0100
@@ -82,6 +82,8 @@
 	return (gdGetC((gdIOCtx *)in));
 }
 
+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);
+
 /* gdImageWBMPCtx
  *  --------------
  *  Write the image as a wbmp file
@@ -93,13 +95,19 @@
  */
 BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
 {
+	_gdImageWBMPCtx(image, fg, out);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
+{
 	int x, y, pos;
 	Wbmp *wbmp;
 
 	/* create the WBMP */
 	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
 		gd_error("Could not create WBMP\n");
-		return;
+		return 1;
 	}
 
 	/* fill up the WBMP structure */
@@ -115,11 +123,15 @@
 
 	/* write the WBMP to a gd file descriptor */
 	if(writewbmp(wbmp, &gd_putout, out)) {
+		freewbmp(wbmp);
 		gd_error("Could not save WBMP\n");
+		return 1;
 	}
 
 	/* des submitted this bugfix: gdFree the memory. */
 	freewbmp(wbmp);
+
+	return 0;
 }
 
 /* gdImageCreateFromWBMPCtx
@@ -206,8 +218,11 @@
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) return NULL;
-	gdImageWBMPCtx(im, fg, out);
-	rv = gdDPExtractData(out, size);
+	if (!_gdImageWBMPCtx(im, fg, out)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free(out);
 	return rv;
 }
Index: libgd2-2.1.0/tests/jpeg/CMakeLists.txt
===================================================================
--- libgd2-2.1.0.orig/tests/jpeg/CMakeLists.txt	2019-01-29 14:48:25.552398898 +0100
+++ libgd2-2.1.0/tests/jpeg/CMakeLists.txt	2019-01-29 14:48:25.540398898 +0100
@@ -1,6 +1,7 @@
 
 SET(TESTS_FILES
 	jpeg_im2im
+	jpeg_ptr_double_free
 	jpeg_null
 	jpeg_read
 	jpeg_empty_file
Index: libgd2-2.1.0/tests/jpeg/jpeg_ptr_double_free.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libgd2-2.1.0/tests/jpeg/jpeg_ptr_double_free.c	2019-01-29 14:48:25.540398898 +0100
@@ -0,0 +1,31 @@
+/**
+ * Test that failure to convert to JPEG returns NULL
+ *
+ * We are creating an image, set its width to zero, and pass this image to
+ * `gdImageJpegPtr()` which is supposed to fail, and as such should return NULL.
+ *
+ * See also <https://github.com/libgd/libgd/issues/381>
+ */
+
+
+#include "gd.h"
+#include "gdtest.h"
+
+
+int main()
+{
+    gdImagePtr src, dst;
+    int size;
+
+    src = gdImageCreateTrueColor(1, 10);
+    gdTestAssert(src != NULL);
+
+    src->sx = 0; /* this hack forces gdImageJpegPtr() to fail */
+
+    dst = gdImageJpegPtr(src, &size, 0);
+    gdTestAssert(dst == NULL);
+
+    gdImageDestroy(src);
+
+    return gdNumFailures();
+}
Index: libgd2-2.1.0/tests/Makefile.am
===================================================================
--- libgd2-2.1.0.orig/tests/Makefile.am	2019-01-29 14:48:25.552398898 +0100
+++ libgd2-2.1.0/tests/Makefile.am	2019-01-29 14:48:25.540398898 +0100
@@ -81,6 +81,7 @@
 	jpeg/jpeg_resolution \
 	jpeg/jpeg_im2im \
 	jpeg/jpeg_null \
+	jpeg/jpeg_ptr_double_free \
 	jpeg/jpeg_read \
 	png/png_null \
 	png/bug00033 \
@@ -112,7 +113,8 @@
 check_PROGRAMS += \
 	jpeg/jpeg_empty_file \
 	jpeg/jpeg_im2im \
-	jpeg/jpeg_null
+	jpeg/jpeg_null \
+	jpeg/jpeg_ptr_double_free
 if HAVE_LIBPNG
 check_PROGRAMS += \
 	jpeg/jpeg_resolution \
Index: libgd2-2.1.0/tests/gdtest/gdtest.c
===================================================================
--- libgd2-2.1.0.orig/tests/gdtest/gdtest.c	2013-06-25 11:58:23.000000000 +0200
+++ libgd2-2.1.0/tests/gdtest/gdtest.c	2019-01-29 15:10:58.932380608 +0100
@@ -205,10 +205,19 @@
 	return res;
 }
 
+static int failureCount = 0;
+
+int gdNumFailures() {
+    return failureCount;
+}
+
 int _gdTestAssert(const char* file, unsigned int line, const char* message, int condition)
 {
 	if (condition) return 1;
 	_gdTestErrorMsg(file, line, "%s", message);
+
+	++failureCount;
+
 	return 0;
 }
 
@@ -222,6 +231,9 @@
 	va_end(args);
 	fprintf(stderr, "%s:%u: %s", file, line, output_buf);
 	fflush(stderr);
+
+	++failureCount;
+
 	return 0;
 }
 /* }}} */
Index: libgd2-2.1.0/tests/gdtest/gdtest.h
===================================================================
--- libgd2-2.1.0.orig/tests/gdtest/gdtest.h	2013-06-25 11:58:23.000000000 +0200
+++ libgd2-2.1.0/tests/gdtest/gdtest.h	2019-01-29 14:49:42.356397860 +0100
@@ -41,4 +41,6 @@
 
 void gdSilence(int priority, const char *format, va_list args);
 
+int gdNumFailures(void);
+
 #endif /* GD_TEST_H */
